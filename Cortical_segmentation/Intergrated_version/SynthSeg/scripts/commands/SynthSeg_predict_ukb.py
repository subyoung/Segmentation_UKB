"""
This script enables to launch predictions with SynthSeg from the terminal.

If you use this code, please cite one of the SynthSeg papers:
https://github.com/BBillot/SynthSeg/blob/master/bibtex.bib

Copyright 2020 Benjamin Billot

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
https://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
"""

# python imports
import os
import sys
from argparse import ArgumentParser

# add main folder to python path and import ./SynthSeg/predict_synthseg.py
synthseg_home = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0]))))
sys.path.append(synthseg_home)
model_dir = os.path.join(synthseg_home, 'models')
labels_dir = os.path.join(synthseg_home, 'data/labels_classes_priors')
from SynthSeg.predict_synthseg_ukb import predict

import datetime
start_time = datetime.datetime.now()

# parse arguments
parser = ArgumentParser(description="SynthSeg", epilog='\n')

# input/outputs
parser.add_argument("--i", help="Image(s) to segment. Can be a path to an image or to a folder.")
parser.add_argument("--o", help="Segmentation output(s). Must be a folder if --i designates a folder.")
parser.add_argument("--parc", action="store_true", help="(optional) Whether to perform cortex parcellation.")
parser.add_argument("--robust", action="store_true", help="(optional) Whether to use robust predictions (slower).")
parser.add_argument("--fast", action="store_true", help="(optional) Bypass some postprocessing for faster predictions.")
parser.add_argument("--ct", action="store_true", help="(optional) Clip intensities to [0,80] for CT scans.")
parser.add_argument("--vol", help="(optional) Path to output CSV file with volumes (mm3) for all regions and subjects.")
parser.add_argument("--qc", help="(optional) Path to output CSV file with qc scores for all subjects.")
parser.add_argument("--post", help="(optional) Posteriors output(s). Must be a folder if --i designates a folder.")
parser.add_argument("--resample", help="(optional) Resampled image(s). Must be a folder if --i designates a folder.")
parser.add_argument("--crop", nargs='+', type=int, help="(optional) Size of 3D patches to analyse. Default is 192.")
parser.add_argument("--threads", type=int, default=1, help="(optional) Number of cores to be used. Default is 1.")
parser.add_argument("--cpu", action="store_true", help="(optional) Enforce running with CPU rather than GPU.")
parser.add_argument("--v1", action="store_true", help="(optional) Use SynthSeg 1.0 (updated 25/06/22).")

parser.add_argument("--resolutionconversion", action="store_true", help="(optional) Convert the resolution of the input image to 1mm isotropic resolution before segmentation.(Updated 24/04/24 by Ziyang)")
parser.add_argument("--keep_intermediate_files", action="store_true", default=False, help="(optional) Keep the intermediate files during the resolution conversion.Default is False to save space.(Updated 24/04/24 by Ziyang)")
parser.add_argument("--relabel", action="store_true", help="(optional) Relabel the segmentation.(Updated 24/04/24 by Ziyang)")
parser.add_argument("--label_correction", action="store_true", help="(optional) Correct the labels in the segmentation using the original mask.(Updated 22/05/24 by Ziyang)")
parser.add_argument("--output_format", type=str, default='nii.gz', help="(optional) Output format of the segmentation. Default is nii.gz. Other options are 'nii' and 'img'. (Updated 21/06/24 by Ziyang)")
parser.add_argument("--save_analyseformat", action="store_true", help="(optional) Save an additional segmentation result in Analyse format.(Updated 24/04/24 by Ziyang)")
parser.add_argument("--save_brain", action="store_true", help="(optional) Save the brain mask and brain generated by SynthSeg. If --label_correction is used, the mask and brain generated by SynthSeg may not be necessary, but they can still be saved. (Updated 22/05/24 by Ziyang)")


# check for no arguments
if len(sys.argv) < 2:
    parser.print_help()
    sys.exit(1)

# parse commandline
args = vars(parser.parse_args())

print('\nProcessing the following arguments:')
# print SynthSeg version and checks boolean params for SynthSeg-robust
if args['robust']:
    args['fast'] = True
    assert not args['v1'], 'The flag --v1 cannot be used with --robust since SynthSeg-robust only came out with 2.0.'
    version = 'SynthSeg-robust 2.0'
else:
    version = 'SynthSeg 1.0' if args['v1'] else 'SynthSeg 2.0'
    if args['fast']:
        version += ' (fast)'
print('\n' + version + '\n')

# enforce CPU processing if necessary
if args['cpu']:
    print('using CPU, hiding all CUDA_VISIBLE_DEVICES')
    os.environ['CUDA_VISIBLE_DEVICES'] = '-1'

# limit the number of threads to be used if running on CPU
import tensorflow as tf
if args['threads'] == 1:
    print('using 1 thread')
else:
    print('using %s threads' % args['threads'])
tf.config.threading.set_inter_op_parallelism_threads(args['threads'])
tf.config.threading.set_intra_op_parallelism_threads(args['threads'])

##################setting gpu memory growth##################
# gpus = tf.config.experimental.list_physical_devices('GPU')
# if gpus:
#     try:
#         # Restrict TensorFlow to only allocate a subset of the available memory on the first GPU
#         desired_memory_mb = 7000  # Example: Limit to 7000MB of memory
#         tf.config.experimental.set_virtual_device_configuration(
#             gpus[0],
#             [tf.config.experimental.VirtualDeviceConfiguration(memory_limit=desired_memory_mb)])
#         logical_gpus = tf.config.experimental.list_logical_devices('GPU')
#         print(len(gpus), "Physical GPUs,", len(logical_gpus), "Logical GPU")
#     except RuntimeError as e:
#         # Virtual devices must be set before GPUs have been initialized
#         print(e)
##############################################################
        

# path models
if args['robust']:
    args['path_model_segmentation'] = os.path.join(model_dir, 'synthseg_robust_2.0.h5')
else:
    args['path_model_segmentation'] = os.path.join(model_dir, 'synthseg_2.0.h5')
args['path_model_parcellation'] = os.path.join(model_dir, 'synthseg_parc_2.0.h5')
args['path_model_qc'] = os.path.join(model_dir, 'synthseg_qc_2.0.h5')

# path labels
args['labels_segmentation'] = os.path.join(labels_dir, 'synthseg_segmentation_labels_2.0.npy')
args['labels_denoiser'] = os.path.join(labels_dir, 'synthseg_denoiser_labels_2.0.npy')
args['labels_parcellation'] = os.path.join(labels_dir, 'synthseg_parcellation_labels.npy')
args['labels_qc'] = os.path.join(labels_dir, 'synthseg_qc_labels_2.0.npy')
args['names_segmentation_labels'] = os.path.join(labels_dir, 'synthseg_segmentation_names_2.0.npy')
args['names_parcellation_labels'] = os.path.join(labels_dir, 'synthseg_parcellation_names.npy')
args['names_qc_labels'] = os.path.join(labels_dir, 'synthseg_qc_names_2.0.npy')
args['topology_classes'] = os.path.join(labels_dir, 'synthseg_topological_classes_2.0.npy')
args['n_neutral_labels'] = 19

# use previous model if needed
if args['v1']:
    args['path_model_segmentation'] = os.path.join(model_dir, 'synthseg_1.0.h5')
    args['labels_segmentation'] = args['labels_segmentation'].replace('_2.0.npy', '.npy')
    args['labels_qc'] = args['labels_qc'].replace('_2.0.npy', '.npy')
    args['names_segmentation_labels'] = args['names_segmentation_labels'].replace('_2.0.npy', '.npy')
    args['names_qc_labels'] = args['names_qc_labels'].replace('_2.0.npy', '.npy')
    args['topology_classes'] = args['topology_classes'].replace('_2.0.npy', '.npy')
    args['n_neutral_labels'] = 18

# check for additional arguments by Ziyang
if args['resolutionconversion']:
    print('Converting the resolution of the input image to 1mm isotropic resolution before segmentation.')
if args['keep_intermediate_files']:
    assert args['resolutionconversion'], 'The flag --keep_intermediate_files can only be used with --resolutionconversion.'
    print('Keeping the intermediate files during the resolution conversion.')
else:
    print('Not keeping the intermediate files during the resolution conversion.')
if args['relabel']:
    print('Relabeling the segmentation.')
if args['label_correction']:
    print('Correcting the labels in the segmentation using the original mask.')

if args['output_format'] == 'nii':
    print('Saving the segmentation in nii format.')
elif args['output_format'] == 'nii.gz':
    print('Saving the segmentation in nii.gz format.')
elif args['output_format'] == 'img':
    assert not args['save_analyseformat'], 'The flag --output_format=img cannot be used with --save_analyseformat.'
    print('Saving the segmentation in img format.')
else:
    print('The output format is not nii, nii.gz or img. Will use default set, which is nii.gz.')
    args['output_format'] = 'nii.gz'

if args['save_analyseformat']:
    assert args['relabel'], 'The flag --save_analyseformat can only be used with --relabel.'
    print('Saving an additional relabeled segmentation result in Analyse format.')
if args['save_brain']:
    #assert not args['label_correction'], 'The flag --save_brain cannot be used with --label_correction.'
    print('Saving the brain mask and brain generated by SynthSeg.')

print ('\n')

# run prediction
predict(path_images=args['i'],
        path_segmentations=args['o'],
        path_model_segmentation=args['path_model_segmentation'],
        labels_segmentation=args['labels_segmentation'],
        robust=args['robust'],
        fast=args['fast'],
        v1=args['v1'],
        do_parcellation=args['parc'],
        n_neutral_labels=args['n_neutral_labels'],
        names_segmentation=args['names_segmentation_labels'],
        labels_denoiser=args['labels_denoiser'],
        path_posteriors=args['post'],
        path_resampled=args['resample'],
        path_volumes=args['vol'],
        path_model_parcellation=args['path_model_parcellation'],
        labels_parcellation=args['labels_parcellation'],
        names_parcellation=args['names_parcellation_labels'],
        path_model_qc=args['path_model_qc'],
        labels_qc=args['labels_qc'],
        path_qc_scores=args['qc'],
        names_qc=args['names_qc_labels'],
        cropping=args['crop'],
        topology_classes=args['topology_classes'],
        ct=args['ct'],

        resolutionconversion=args['resolutionconversion'],
        keep_intermediate_files=args['keep_intermediate_files'],
        relabel=args['relabel'],
        label_correction=args['label_correction'],
        output_format=args['output_format'],
        save_analyseformat=args['save_analyseformat'],
        save_brain=args['save_brain'],
        start_time=start_time)

# endtime = time.time()
# print('\nTotal processing time: ' + str(endtime - start_time) + 's')


